Skip to main content
PLURALSIGHT
Home
Browse
Feed
Paths
Mentors
Channels
Bookmarks
Notes
Angular Reactive Forms
by Deborah Kurata

You can build forms in Angular by using a Reactive approach by defining the form model and validation in your component code. This course details how to build Reactive forms, validate user-entered data, and save that data using HTTP.

Resume CourseBookmarkAdd to ChannelLive mentoring
Table of contents
Description
Transcript
Exercise files
Discussion
Recommended
Course Overview

Course Overview

Hello, my name is Deborah Kurata. Welcome to my course, Angular 2: Reactive Forms, from Pluralsight. Did you know that there are two different ways to create data entry forms in Angular? The template-driven approach uses HTML with two-way data binding. The Reactive approach manages the form and its data in the component code. This course looks at the similarities and differences between the template-driven and Reactive forms approaches, helping you decide the best technique to use for your team and your project. It details how to use the Reactive forms approach, shifting the logic for the form from the HTML to the component code, giving you more flexibility and more control. It includes techniques such as watching for and reacting to user changes, and dynamically duplicating input elements, allowing you to build powerful and Reactive forms. The course walks through validation scenarios, such as adjusting validation at run time and custom and cross-field validation. And since forms display and save data, you'll learn how to send get, post, put, and delete requests to a web server using HTTP and observables. By the end of this course, you'll have the skills to build powerful and dynamic data entry forms using the Reactive forms approach. I hope you'll join me on this journey through Angular 2: Reactive Forms, from Pluralsight.

Introduction

Introduction

We can build forms in Angular 2 with a template-driven approach using HTML and data binding, or we can build Reactive forms using a model-driven approach by defining the form model and validation in our component code. Welcome to Angular 2: Reactive Forms, from Pluralsight. My name is Deborah Kurata, and this course provides the concepts you need to build Reactive forms, validate user-entered data, and save that data using HTTP. We've all filled out our share of online forms. Register for an event, fill out a form. Make a dentist appointment, fill out a form. And often our company runs on online forms, forms for tracking our time, forms for booking conference rooms, forms for managing inventory, and so on. In this introductory module, we start with a short overview of forms in Angular. We consider several suggestions for getting the most from this course. We explore the demo form and sample application that we will use in this course, and we look at the topics we'll cover in the remainder of this course. Okay then, let's get started.

Angular Forms

When we build a form with Angular, we always create a component class for the form logic, and a template for the form's user interface. If the form updates data, the component class calls a service to retrieve existing data from a database or other data store on a server somewhere, and that data is displayed as default values on the form. We then collect user entries, validating the data as the user types. If needed, we display validation messages back to the user. When the user submits the form, the component class calls a service to pass the validated data back to the database or other data store on the server, and the user's entries or updates are saved. How do we build the template and component class for our forms? Angular provides two techniques for building forms, template-driven and Reactive, previously called model-driven. Both techniques share the same basic concepts, but as its name implies, template-driven forms put the responsibility for the forms squarely in the template, which we define with basic HTML and data binding. Reactive forms shift much of that responsibility to the component class. We still create the template with HTML, but we manage the data and validation in the component code. Let's take a high level look at the strengths of each technique. There are many advantages to building forms using a template-driven approach. The template-driven technique is straightforward and easy to use, and it looks very familiar if you've built forms with Angular 1. Because template-driven forms rely heaving on two-way data binding, we don't have to write any code to copy the data to the input elements, or track the user's entries, it's all handled automatically. Speaking of automatically, Angular also automatically tracks form and input element state. We can use this state information to determine when the form is invalid and disable the Save button, for example. With much more of the logic for our form in our class, Reactive forms provide more flexibility, they handle more complex validation scenarios, such as changing validation based on a user's selection or on the form state. Reactive forms do not use data binding, so the form cannot mutate our data model. The component code controls how to handle any changes to the data; some developers prefer this immutability. Using Reactive forms makes it easier to perform an action on a value change, such as transforming the value to uppercase or performing a partial lookup. We have access to reactive transformations, such as DebounceTime to delay reacting to user input, and DistinctUntilChanged to ignore values that are the same as previously processed values. Reactive forms make it easier to dynamically add input elements to the form, so we could allow the user to enter any number of addresses, for example. And since more of the logic and validation are in the code, not the template, some developers find that the logic is easier to unit test. There is no magic going on under the hood when you work with Reactive forms, everything is direct, there is no template between your code and your data structures. The primary issue with Reactive forms, however, is that they require more code. Depending on your team, its experience, and its background, some of these factors may weigh more heavily than others. It is important to select the appropriate forms approach that works best for you and your team. To help you make that decision, we'll dive deeper into their similarities and differences, and examine the code for both techniques in the next modules. For now, let's look at some tips for getting the most from this course.

Get the Most from This Course

First, the prerequisites. To get the most from this course, it is important that you know the basics of Angular 2. This means understanding Angular modules, components, templates, including binding, services, and basic routing. If you don't have the requisite knowledge, consider taking one of the introductory Angular 2 courses here on Pluralsight, such as Angular 2: Getting Started or Angular 2: First Look. You do not need any prior knowledge of Angular forms; we'll cover what you need in this course. Another way to get the most from this course is to join the discussion. Thoughts, comments, or questions as you watch this course? Feel free to use the Discussion tab, you can find the link to the discussion on the Pluralsight page for this course, or follow me on Twitter. It would be great to hear about your experiences with Reactive forms. There is also a blog post specifically for this course at the URL shown here. This post identifies common issues along with their solutions. If you have any problems with the code for the course, check here first, there may already be a solution posted. When building web applications, regardless of the technologies we use, there are lots of steps and places where things can go wrong. That's when a good checklist can come in. I'll present checklists at the end of many of the modules, and we'll use them as a brief review of what was covered in that module. Feel free to jump ahead to the checklist if you have any problems when coding along with the demos, and consider referencing these checklists as you start building your own Angular forms applications. Coding along with the demos is another great way to get the most from this course. Though not required, it is often helpful to try out the presented code as you navigate through the course. To get you started, I've set up a public GitHub repository specifically for this course, it is called Angular2-ReactiveForms, and you can find it at this URL. The starter files for the forms demo are here, you can use these files as a starting point if you want to code along with the demos. If you'd prefer to follow along with the completed demo form code, you can find that here. Toward the end of this course, we'll look at a form in the context of a more full-featured sample application; that sample application is here. If you are new to GitHub, simply click this button to download all of the code as a zip file. So what's in this code? Let's take a look.

Demo Form and Sample Application

We start with a simple demo sign up form built using the template-driven approach. We examine the code, then rebuild this form using the Reactive forms approach to understand the key differences between the two techniques. Then we add more features, such as custom validation, cross-field validation, and dynamic addition of multiple addresses. Later in this course, we'll examine a second Reactive form in the context of a more full-featured Angular application. The sample application demonstrates routing to the form, including routing guards, and details the data access service to communicate with a back-end server via HTTP to retrieve and save data. Let's see this sample application in action. Welcome to Acme Product Management. As its name implies, this application manages our company's current list of products. We'll use this application later in this course, when we look at a Reactive form in the context of a more full-featured application. This application may look familiar if you have seen the Angular 2: Getting Started course here on Pluralsight. I've incorporated an edit form, and add, edit, and delete operations into the sample application that was built in the Getting Started course. Here at the top is our menu for access to the key features of the application. In a real application, there may be more options here, but we want to focus on building a Reactive form, so I've limited the application to basic functionality. Clicking on the Product List option displays the Product List page. From here we can click the Edit button to edit the product. Clicking on the product name navigates to the Product Detail page; we also have an Edit button here. Clicking the Edit button displays the Reactive form for editing the selected product. Notice that each of the fields are populated with existing values, the user can edit product information, or click Delete to delete the product. If the user makes a mistake and breaks one of the validation rules, the application displays a validation error message, and the Save button is disabled. Let's enter a new product name. If the users tries to navigate away from the page, we have a routing guard to notify them of their unsaved changes. If the user wants more search tags for this product, they can click Add Tag. This dynamically duplicates the input elements, the label and input box in this example, so the user can add any number of search tags. Clicking Save saves the product and returns to the Product List page where we see our updated value. Clicking the Add Product option displays the same form, but initialized for entry of a new product. Notice that the Save is disabled until the form values are valid. Once all of the data is valid, clicking the Save saves the new product and navigates back to the Product List page. Here we see our new product. So that's the basics of a sample application that we'll look at later in this course. Now let's finish up this introductory module with a look at the outline for the remainder of this course.

Course Outline

In this course, we start with a more detailed look at the similarities and differences between template- driven and Reactive forms, including an examination of the building blocks that make up the form model. Next, we build a Reactive form, first using the form model building blocks directly, and then using FormBuilder to simplify the code. We add validation rules and error messages to validate the user's entries, including custom validation and cross-field validation. With Reactive forms, we can adjust how a form works reactively based on user entries and selections. For example, based on a user's selection, we can change the form's validation rules. We'll see how to watch for user changes and react to those changes. We'll also examine reactive transformations, such as DebounceTime. Sometimes a single entry is not enough, the user may need to enter multiple email addresses, or multiple address blocks, or multiple search tags. In that case, we can dynamically duplicate input elements. We'll see how to do that with Reactive forms and form arrays. Then we switch gears a bit, and examine a Reactive form in the context of a more full-featured sample application. We'll look at techniques for routing to the form, setting up routing guards, and building reusable custom validation. In many scenarios the key purpose of a form is to collect or edit data that is then stored in a database or other data stores somewhere. To do that we need to deal with CRUD, or create, read, update, and delete operations for retrieving and saving data to a back-end server with HTTP. By the end of this course we'll have a simple, but fully operational Angular application, that includes a Reactive form with full CRUD support. You can use this application as a reference for your own development. Let's get started.

Template-driven vs. Reactive Forms

Introduction

To determine whether Reactive forms is the right choice for your project and your team, it is important to understand your form options. Welcome back to Angular 2: Reactive Forms, from Pluralsight. My name is Deborah Kurata, and in this module we lay the foundation for understanding Reactive forms by looking at the similarities and differences between it and template-driven forms. Coffee or tea? Cash or credit? Paper or plastic? Right or left? We face many choices every day, and when it comes to building forms in Angular, our choice is whether to use a template-driven or Reactive forms approach. In this module, we start with the Angular form building blocks used by both approaches, FormGroup and FormControl. We see what they are, and what they do. Next, we walk through the template syntax for both template-driven and Reactive forms. Then we examine a simple template-driven form. Our focus is not on all the features of Template-driven forms, but rather on understanding enough to compare it clearly with Reactive forms. Lastly, we look at several complex form processing scenarios as a segue to Reactive forms. Let's get started.

Form Building Blocks

One of the key uses of forms is for the user to enter data that we save somewhere. Say that we display a form to the user, like this form. We don't want to save data that is incomplete or invalid, so we validate the user's entries as needed. If the entered information is not valid, we indicate that to the user and display an appropriate validation error message. There are many ways to style invalid entries and display the validation message, this is the simple technique we will use. We also want to disable the Save button until the input elements contain valid data. To achieve all of this, we track the state of each input element and the state of the form itself. Angular has a set of predefined form and input element states. These states define whether the user has changed a value in an input element. If the value is unchanged, the state of the input element is pristine. Changed values have a state of dirty. If all input elements on a form are pristine, then the form itself is pristine. If any input element on the form is dirty, then the form state is dirty. A state and an array track validity. The input element state is valid if it passes all defined validation rules. The form itself is valid if all input elements on the form are valid. Validation errors are added to an errors collection. The key of each array element is the name of the validation rule associated with the error. These states define whether the user has visited an input element. A value of touched means the user has set focus into the input element, and then left the input element. Untouched is set if the user has not set focus, then left the input element. A form is touched if any input element has been touched. These visited states are useful to prevent displaying the required validation error message until the user has had a chance to enter something. How do we track all of this state information? Luckily for us, Angular has building blocks that define a form model, which tracks all of this state, plus the value of each input element. These building blocks are used by both template-driven and Reactive forms to track state and values. FormControl tracks the value and state of an individual input element, such as an input box. FormGroup tracks the value and state of a group of form controls. A form itself is managed as a form group, because what is a form but a group of input elements whose state and value we wish to track together. But any group of input elements on a form can comprise a FormGroup, we could group the input elements for a mailing address block, for example. And FormGroups themselves can be nested within other FormGroups. For clarity, I'll often refer to the forms FormGroup as the root FormGroup. These building blocks are actually classes provided when we work with Angular forms. Instances of these classes define the form model. I've mentioned the term form model several times now. What is a form model exactly? A form model is the data structure that represents the HTML form, and it looks like this. The structure of the form model reflects the form and input elements in the template. In most cases, each input element within the HTML form has a corresponding form control in the form model. The form model retains form state, such as dirty or valid. It retains the user's entries and its value property. As the user types into any input element on the form, the value property is changed accordingly. The form model also tracks all of the FormControls and nested FormGroups within the form, along with their state and value. Don't confuse the form model with the data model that we use with data binding. We'll see both the data model and form model when we get to the demo. We use these properties from the form model anytime we need to know the state or value of a FormControl or FormGroup. This form model is the same for both template-driven and Reactive forms, but how it is created is different. When using a template-driven approach we write HTML in our template for the form element, each input element, data binding, validation rules using attributes, and validation error messages. Angular automatically generates the associated form model, we can then use the form model as needed. In our component class, we define properties for the data binding. These properties represent our data model. We also implement methods for form operations, such as getting the data for display on the form, and saving that data on a submit. Two-way data binding is a key part of template-driven forms, as it keeps all of the data on the form in synchronization with properties in the component class. Reactive forms shift the responsibility for creating the form model to the component class. We define the form model by creating the instances of the FormGroup and FormControl building blocks in our component class. We define the validation rules in the class. We can even handle display of validation error messages in the class. We manage the data for the form in the class, no data binding in the HTML. And the class provides methods for form processing, such as handling the submit. We still define the visual parts of the form in the template, so we create the form element and input elements in the template. We then bind these input elements to the form model defined in the component class. So instead of binding the input elements to the data model properties directly, we bind to the form model we build in our component class.

Form Directives

Template-driven and Reactive forms use entirely different sets of directives for binding the FormControl and FormGroup building blocks to the form and input elements in the template. When using template-driven forms, we first import the forms module to bring in the appropriate set of directives. This includes ngForm to access the form model Angular generates for us, ngModel for two-way binding, and to access the input element state defined in the generated form model, and ngModelGroup for grouping input elements within the form. When we add a form element to our template, Angular automatically assigns the ngForm directive to that form. Angular creates the form model starting with the root FormGroup instance, and automatically binds it to the form to track the form value and state. We never have to apply the ngForm directive ourselves. If we want to access the form model state information in our template, we export the ngForm directive into a template reference variable like this. Here we use a hash to define a template reference variable called signupForm, and set it equal to ngForm, this variable then references the form's root FormGroup instance. Anytime we want to access the form model, we use this template reference variable. In this example, we check the valid property of the FormGroup instance to disable the Save button if the form is not valid. We'll see this in context in the upcoming demo. If you've done any two-way data binding in Angular, you are already familiar with the ngModel directive. We use this directive on each input element to keep the component class property in sync with the user-entered value. In this example, any change to the firstName input element is automatically reflected in the firstName property of the customer defined in the component class. When we add an ngModel to an input element within a form, Angular automatically creates a FormControl instance, and adds it to the form model using the input element's name as the key, hence the reason we need the name attribute here. Angular uses that name attribute for the FormControl instance key. The FormControl instances tracks the input element's value and state. We can access the FormControl state by exporting the ngModel directive into a template reference variable. Here we use a hash to define a template reference variable named firstNameVar, and set it equal to ngModel. This variable then references the form control instance for this input element. We can use the template reference variable to access the FormControl state. For example, we can use the valid property of the FormControl to determine when to display validation messages. We'll see that in the upcoming demo. To use Reactive forms, we first input the ReactiveFormsModule to bring in its appropriate set of directives. As you can see, this is an entirely different set of directives then for the template-driven approach. Notice how close these directive names map to the FormGroup and FormControl building blocks. With the Reactive forms approach, Angular does not create a form model for us, rather we create it ourselves in our component class. We then use these directives in the template to bind the form and input elements to our defined form model. So for both techniques, building an Angular form requires building a template with the appropriate set of directives. Let's take a closer look.

Template Syntax for Forms

If you've built any web-based forms you recognize this, no Angular here, it's just HTML. We have a form element, we have input elements, such as this input box, along with a label for each data entry field we want to display. Each input element has attributes, such as these validation attributes. In this example, the first name is required and has a minimum length of 3 characters. Yeah, I know, this minlength validation is a bit funky. How would P. Diddy enter his name here, for example? But I wanted to show multiple validation rules for this element. We also have a button for the user to submit their entries. When building Angular forms we use this same HTML, and just add the appropriate directives for the template-driven or Reactive approach. Let's look at this form using, first, a template-driven approach, and then Reactive. A template-driven form looks like this. We still have the form element and we're using event binding to bind to a save method when the user submits the form using the Save button, let's skip the div element for a moment. We have the same label from this simple HTML example, and the same input element with a little more stuff attached to it. Template-driven forms leverage the HTML validation attributes for its validation, so those are still here. One of the key features of template-driven forms is how it leverages data binding using ngModel. Here we bind a property from our component class to the value of this input element. Two-way data binding keeps the input element value and the property value in sync. Template-driven forms require the name attribute to properly associate the FormControl with the FormGroup in the generated form model. And here we define a template reference variable to access the FormControl instance. Going back to that div element, we use the defined template reference variable and check the FormControl state properties to determine whether or not to style the input element as an error. Here we are referencing the has-error style class from the Bootstrap style framework. The first part of this and operation is checking the FormControl touched state. If the user has touched the element, meaning the user set focus to and left the field, than touched is true. The second part of this and operation is checking the FormControl valid state. Angular automatically performs the validation as defined by the validation attributes. If the input element's value is not valid, the valid property is not true. If touched is true and the input element value is not valid, then the div element class changes to has-error, and the field and its label turn red. So, why are we checking touched and not valid? Because when the form is displayed empty, we don't want the required validation to show the input elements as an error before the user has a chance to enter something. The span tag displays our validation message. Note that we are only showing one message here. We'll see how to display both our required field message and our min length message when we get to the demo. We again use the form control state properties to determine whether to display the message. Here we check the touched property and the errors collection. If the input element was touched and the errors collection contains any values; we display the error message. How about the Reactive form template? Recall that the form model is built in the component class, so no need for template reference variables. Reactive forms do not use two-way binding, so no ngModel or name attribute. And with Reactive forms, the validation is defined in the class, so no validation attributes here either. We still have the form element, but it now binds the formGroup directive to the form model we create in our component class. We still have a label and input element for each data entry field, but now each input element is bound to the name of a formControl instance in the form model. To display the validation message and set the error style, the template uses the formError property defined in the component class. We'll look at the syntax in detail and build our own Reactive form in the next module, but first let's spend a moment looking at the code for a template-driven form, just enough to have the background information we need to compare it with Reactive forms.

Template-driven Form: Template

In this demo, we'll take a quick look at a template-driven form. If you'd like to code along with the course, now is a good time to download the demo project from my GitHub repo here. The first part of this course works with a demo application starting with Demo-Start. Later in the course, we'll add a form to a more full-featured application, APM, but we'll ignore that project for now. To code along, you'll need a recent version of npm to install all of the libraries for the Demo-Start application. I've downloaded the Demo-Start project and moved it to a Demo folder, I then opened the Demo folder in VS Code, but you can use any desired editor. VS Code now has an integrated terminal, we can open that from the View menu, or with the defined hotkey. From here you can type npm install to install the packages for this demo project. I've already done this step, so the node_modules are already in place. I can then type npm start to launch the application. Here is a simple form for a customer to sign up for a mailing list. These three fields are required, but have not yet been entered. Even though the form is current invalid, notice that no validation messages are yet displayed, but because the form state is currently invalid, the Save button is disabled. You may have noticed this extra data down here below the form, I'm displaying some of the values from the form model that Angular automatically generated for us. The Dirty state of the form is currently false, because we have not yet interacted with the form. The Touched state of the form is also false because we have not touched any of the input elements. The Valid state is false because the first three input elements have the required attribute, and we have no value in those fields. The root FormGroup's Value property displays the name of each input element, along with its current value, which is empty at this point. If we set focus to the firstName input element, then leave that element, the element has been touched, and we see the validation error message. The Touched state displayed below the form is now true. If we enter one character, we see the message change to a different validation message, and now that we've typed something, the Dirty state is true. Notice also that the Value is changed to show the entered text. If we finish data entry, the validation message disappears, but the Valid property is still false; all input elements in the root FormGroup must be valid for the form state to be valid. To complete the form, I'll put in the last name and email address. The email validation message appears as soon as we type one character, because one character is not a valid email address. We'll see later how we can make this better, but as soon as the email address is of a correct format, the validation message disappears. When we've entered valid values into each of the required fields, the Save button is enabled. If we check the Send me your catalog checkbox, we see additional fields for entry of a postal address. This forms demonstrates the input box, checkbox, radio button, and select box HTML elements. Notice also that additional items are added to the Value object. Let's uncheck this for now to shorten the form. I'm logging the entire root FormGroup instance to the console when the user clicks on Save, so let's use the browser's developer tools to take a look, then click Save. Here is the root FormGroup, we can drill down. Let's scroll to the public members. The FormGroup's dirty property is true, just as we've seen, as is touched. Controls here is the list of each FormControl associated with this form. The name of each control is the name we defined with the input element name attribute, as is the name used in the value object. So template-driven forms gives us all of this information with very little effort on our part. Now let's look at the code. Here is the template for the Sign Up form. Notice all of these style classes, we are using the Bootstrap styling framework here to make our form look good, but you don't have to. Here is the form element, quite similar to the code we saw earlier in the slides. We use the novalidate attribute to tell the browser not to perform its validation, but rather to let Angular validate the entries. Here we set the templates reference variable to our form model, and when the user submits the form, we pass that form model reference to our component's save method, that way our component code can access the form model state or values. Here is the firstName input element; wow, that's quite a bit of HTML. We use the ngClass directive to set the has-error style class and turn the elements red when the input element was touched or dirty and is not valid. We set the validation attributes on the input element itself, here we have required and minlength. We use ngModel for the two-way data binding, we set the name attribute so the FormControl instance is associated correctly in the form model. We define the template reference variable to use for validation styling and messages. And we define the validation messages for the two different possible validation errors, notice the use of the errors collection here. When Angular detects a validation error, it adds an entry to the errors collection using the name of the validation rule as the key. We can use that name to display the appropriate validation message. Here, we use errors.required to display the message appropriate for the required field validation rule. And we use errors.minlength to display the message appropriate for the minlength validation rule. Notice how this similar code is repeated for each input element on our form. One thing to note about the email validation, as of the time of this recording, Angular forms doesn't yet support the validators for the HTML5 input types, such as email, phone, and date, so code like this will not work. We instead added a simple pattern for a very basic email format validation. Way down at the bottom is the Submit button, notice that we are using the form's template reference variable to access the form model's valid property. We disable the button if the form is not valid, and here, after the form, we are using the form's template reference variable to display the properties we were looking at in the browser. We display the Dirty, Touched, and Valid properties, we also display the Value of the form model, piped into a JSON structure for more readable format. Now let's look at the component.

Template-driven Form: Component

Wow, not much here. In the component class we define the code to manage our form. There are two key bits of information here in our class. The customer property manages the instance of the customer data that we are binding to in our template. We can use Go to Definition to view the definition of the customer data model here. We're using a class and not an interface in this case, because we want to create a new instance of this class for the new customer information. The other important bit of code here is the save method. Our template binds to this method, which is executed when the user submits the form. We pass in the form model from the template so we can check the form state and view its values. For example, we could skip saving if the user clicked Save without making any changes by checking the form's dirty property. It is here that we would call a service to save our data to a back-end server. We'll see how to build save functionality later in this course. The bottom line here is that the template-driven forms approach minimizes the component class code we need to write, but it is heavy on the template code; each control takes a full page of HTML. When using template-driven forms, Angular automatically creates the form model, we can then use that to track form and control state, and the ngModel two-way binding takes care of keeping our class properties in sync. But often in a real application, forms are more complex than this. Let's look at some of these scenarios.

Complex Scenarios

Our story begins a week ago when our team met with Marketing to understand the requirements for a signup feature. We then developed a first prototype of the form and are presenting it to them today. We show them the form and how well it validates the customer's entries per their specifications, and when we click the Send me your catalog button, it allows the customer to put in a mailing address to receive our catalog. This prompts our first change request. Can we allow multiple addresses, they ask? It seems that our customers often want to receive catalogs at both their home and work, and they also want to ensure their subordinates get catalogs too. Who wouldn't want more catalogs? This generates some additional ideas. Can we watch what the user types into the Street Address and provide suggestions? This would make it easier for the user to send the catalog to multiple people at the same company. Then from the back of the room we get a question, can we see that first name validation again? We show them. I don't like that the customer sees an error when they type in one character, can't we wait until they stop typing to determine if they've entered enough characters? They continue. Many of our customers also like to receive notifications from us via email or text message, can we ask for their preference and add a phone number? Be sure to make the phone number required only if they pick notifications via text message. We take our list of change requests, and head back to our office. Implementing these change requests sounds like we'll end up with a complex set of HTML that will be difficult to build and maintain over time. There has to be another way. As we've just seen, template-driven forms is mostly just HTML, and is easy to use, but as soon as we start handling more complex scenarios, things get harder and messier. Scenarios such as dynamically adding input elements to the form, such as multiple address blocks, adding code to watch what the user types and reacting accordingly, waiting validation until the user stops typing, providing different validation rules for different situations, and what if your team prefers working with immutable data? That means you need to forgo two-way data binding, what then? These scenarios are where the Reactive forms approach really shines, as we'll see through the remainder of this course.

Summary

In summary, we can build forms in Angular with the template-driven approach, or with a Reactive approach. In the template-driven approach, the form model defining the root FormGroup, FormControls, and any nested FormGroups is automatically generated. The validation rules are defined in the HTML, and the input element values and data model properties are kept in sync automatically using two-way data binding. With Reactive forms, we manually create the FormGroups and FormControls for the form model in our component class. We add the validation in the class, and we forgo two-way data binding, instead managing the data flow ourselves. In this module, we looked at the Angular form building blocks for building the form model, FormGroup and FormControl. We saw how template-driven and Reactive forms use different directives in their template syntax to work with these building blocks. To clearly compare template-driven to Reactive forms, we examined the code for a template driven form, and we peeked at the data managed by the generated form model. Lastly, we went through a few complex scenarios that may be better suited for a Reactive forms approach. Next up, let's try out Reactive forms.

Building a Reactive Form

Introduction

Building a form using the Reactive approach means more component code and less HTML. Welcome back to Angular 2: Reactive Forms, from Pluralsight. My name is Deborah Kurata, and in this module we walk through building a simple reactive form with a focus on the basics. We'll expand on these basics throughout the remainder of this course. Sometimes a simple form is all we need, then the template-driven forms approach makes sense, it's quick and easy, and gives you a lot of functionality with very little code. Other times we need more. If you need more functionality, more flexibility, or more control of your forms and their associated data, selecting the Reactive forms approach may be the better choice. In this module, we build a Reactive form, we start with the component class. We update the Angular module to pull in the Reactive form directives, then we modify the template using those directives. We look at how to use setValue and patchValue to update form values. Lastly, we see how to simplify our component class with FormBuilder. Let's get started.

The Component Class

Recall from the prior module that when we use the template-driven approach, Angular automatically generates the form model by creating the FormGroup and FormControl instances for us, and we use ngModel for two-way binding to keep the user's entries and the data model properties in sync. With the Reactive forms approach, we define the form model by creating the FormGroup and FormControl instances ourselves in our component class. We then bind the template to the form model; this means that our form is not directly modifying our data model. So how do we create the form model? Every form model requires at least one FormGroup, which I call the root FormGroup. This is the FormGroup that represents the entire form. The data structure for our demo form's root FormGroup is shown here. It contains properties to retain state, to set default values, and retain user entries, and a child controls collection that represents the content of the form. A form model often has one FormControl in this controls collection for each input element on the form. Though this is not required, we could have input elements on our form that we don't need to track. For example, we could have a checkbox or a select element that manages part of the UI, but does not need to be tracked by our form model. The controls collection can included nested FormGroups to group sets of controls or other nested FormGroups. We'll look at nested FormGroups later in this course. The controls collection can also include FormArrays to work with groups of FormControls or FormGroups as an array. We'll try out FormArrays later in this course. We start creation of our form model with the root FormGroup. One way to create that root FormGroup is shown here. This code imports the FormGroup from angular/forms, so we can use it as the data type for our form model. We declare the root FormGroup here, this property holds the reference to our form model. Our form collects data from our customers, so we'll call it customerForm. Here we define our data model, we are managing customer data so we call it Customer. In the ngOnInit lifecycle hook method, we assign the customerForm property to a new instance of the FormGroup; this creates the root FormGroup for the form model. We could put this code in the constructor instead, but we selected to use ngOnInit to ensure the component and template are initialized before building the form model. In the FormGroup constructor we pass in an object; this object contains the FormControls and any nested FormGroups that comprise the contents of this root FormGroup. Like this, we first add FormControl to the import statement from angular/forms. In the FormGroup constructor, we add a set of key and value pairs. The key is the FormControl name, and the value is a new instance of a FormControl. We repeat this, one for each input element on the form. We can optionally pass a default value to the FormControl constructor as shown here. In this case, we pass true as the default value for the sendCatalog input element. We can also pass validation rules here in the FormControl constructor. We'll talk about validation in the next module. Let's jump into a demo and see how to change our current template-driven Form into a Reactive form.

The Component Class: Demo

In this demo, we build the form model for our demo form. We are back in our demo project just as we left it from the prior module. We are about to switch our demo form from the template-driven approach to the Reactive approach, so if you want to retain the code for the template-driven approach for future reference, now is the time to make a copy of your project folder. Are we ready to tackle the Reactive forms approach? Let's begin with the component class. First, let's delete the code we added specifically to look at the template-driven forms model. We don't need to pass the form into the save method, so let's delete that. Then we no longer need ngForm here, so we can delete that as well. Whenever we build a form using the Reactive approach, we start by importing our building blocks because we know we're going to need them. We import both FormGroup and FormControl from angular/forms. With the Reactive forms approach, we explicitly create instances of these building blocks to define our form model. Let's specify a property from the root FormGroup and call it customerForm, its type is FormGroup. This root FormGroup defines our form model. Our template will bind to this property to associate the HTML form element with this root FormGroup instance. We'll use the same data model as with the template-driven approach. Let's make one more change here to fix up our console.log. Now we'll log our customerForm property using this. Now we need to create and initialize this FormGroup property. We could do it right here on the declaration, or we could add it to the component class constructor, or we could put it in a lifecycle hook. Let's add it to the OnInit lifecycle hook, so that the instance is created when the form is initialized. First we import OnInit from angular/core, then we add the implements keyword to tell TypeScript that we want to implement the OnInit interface. Lastly, we implement the ngOnInit method. In this method we use the conventional syntax to create an instance of the FormGroup class using the new keyword, this.customerForm = new FormGroup. This creates an instance of the FormGroup and assigns it to our CustomerForm property. But we see a syntax error here. If we hover over this error we see that the FormGroup constructor requires that we pass in a set of controls that are associated with this FormGroup, each control is defined with a key and value pair where the key is the control name and the value is an AbstractControl. AbstractControl is the base class for FormControl and FormGroup. This means that our FormGroup can be initialized with FormControls and nested FormGroups. For now, we'll just initialize the FormGroup with a set of FormControls. We're passing in an object so we use curly braces, then we add a FormControl for each input element in the templates form. Let's start with the first name. We'll give it a control name of firstName and create a new FormControl instance using the new keyword. We repeat this syntax for the lastName, and create a new FormControl instance for it. Same for the email address, and the sendCatalog flag. If we want to set a default value in any of the associated input elements, we pass that to the FormControl constructor. Our Marketing Department, of course, wants the Send catalog option checked on by default, so we set that default by simply passing true into the constructor for the sendCatalog FormControl. We've now defined our form's root FormGroup with a FormControl for each of our four input elements. This structure is the form model, and tracks the form value and state. Don't confuse this form model with our data model. The form model defines the set of FormGroups and FormControls that match up with the HTML form and input elements. The data model defines the data passed to and from a back-end server; we are using the same Customer class data model as the template-driven approach. This is a good start, but before we can update the template to bind to our FormGroup and FormControls, we need to pull in the appropriate directives.

The Angular Module

We can think of an Angular module as a box. The box contains a related set of components. The templates associated with any component we declare in an Angular module can only access directives declared or imported into that same Angular module. If your Customer-Components template wants to use the Reactive forms directives, the Reactive-FormsModule must be added to the imports array in the same Angular module. If you are not familiar with Angular modules, consider watching the Angular 2: Getting Started course, which covers Angular modules in detail. Let's update our Angular module now. We are looking at the application's root Angular module called AppModule; it is here that we declared our CustomerComponent. The template in the CustomerComponent wants to use the Reactive forms directives, so it is in the same Angular module that we add the Reactive FormsModule to the imports array. Recall that FormsModule was for template-driven forms. Let's just change that to ReactiveFormsModule here and here. We are now set up to use the Reactive Forms directives. The templates associated with any component declared in this Angular module can now access these Reactive forms directives. Let's update our template next.

The Template

Now that we've defined the form model with its root FormGroup and its associated FormControls in the component class, we can update the template to bind to that form model. We bind the form to the FormGroup, and each input element to its associated FormControl using the Reactive forms directives. As we saw in the last module, these are the directives provided for Reactive Forms, we'll look at formGroup and formControlName here. We'll look at more of these directives later in this course. We use the formGroup directive to bind the form element in the template to the root FormGroup of our form model. We use square brackets to denote property binding, and assign it to the form model property from our component class. The form then knows not to build its own form model, and to instead use the one defined by the customerForm property. We use the formControlName directive to bind each input element to its associated FormControl. We bind to the name of the FormControl instance as defined in the form model. Here, we bind to the firstName formControl. Notice that there are no square brackets here, we are binding to a simple string name, not to a property. We add the formControlName directive to every input element within the form that we want to track. For styling, display of the validation error messages, and other purposes, the template may want to access the form model properties. For example, we may want to access the firstName FormControl properties to determine if the first name input element was touched or is valid. There are several techniques for accessing the form model properties. One option is to navigate through the form model hierarchy. For example, to access the valid property for the firstName FormControl, we would use customerForm, our form model, .controls to access the collection of controls on the form, .firstName to access the first name FormControl, and .valid to access the desired property of that control. Alternatively, we can take advantage of the FormGroup's get method to reference the FormControl. We would use customerForm, our form model, .get to call the get method, passing in firstName to find the reference to the first name control, and .valid to access the desired property of that control. This syntax is often shorter, especially when working with nested FormGroups. Watch the quotes here because often this syntax is within a quoted string, if the outside quoted string uses double quotes, then this argument should be in single quotes. A third option is to define a separate property in the component class for the input element. We then use this property when creating the FormGroup. In the template, we can then reference the FormControl with this property. This technique is most useful for controls referenced frequently in the template or in the code. Let's try out the FormGroup and FormControl name directives in our template. Let's start with a form element. We associate the form element with the root FormGroup, we do that using the formGroup directive to bind the form element to the FormGroup instance property we defined in the component class. We'll use square brackets to define property binding, and bind to our customerForm property. We can delete the template reference variable here and here, because our template can access the customerForm property directly. Recall that the Save button was also using the signupForm template reference variable. Here, we can replace the template reference variable with our customerForm property, our button is still disabled if our FormGroup is not valid, but now we reference the FormGroup instance we created instead of one that Angular had generated for us. And if we still want to see the values of our FormGroup, we can change these logging lines to use customerForm as well. Next, let's hook up our input elements starting with the first name. We'll remove the ngModel, we no longer need the name attribute, and we'll delete the template reference variable. Instead, we'll use the formControlName directive to bind this input element to the name of the associated FormControl, in this case firstName. We don't need square brackets here because we are binding to a simple string, not a property. We then replace the template reference variable here in the div that sets the validation error style. We can use any one of the three techniques we saw in the slides to reference the desired form model object. I'll use Search/Replace to quickly replace the template reference variables with the customerForm get method. This is looking a bit messy here with lots of logic that may be better in the component class. We'll refactor this code a little later in this course. For now I'll go off and repeat these changes for the last name, email address, and send catalog checkbox. If you are coding along, be sure to delete the ngModel directive, name attribute, and template reference variable from each input element, and add the form ControlName directive, then use Search/Replace to replace each reference to the template reference variable with a customerForm.get method. Note that the directive name and the FormControl string names are case sensitive. Are we ready to move on? We still have all of these other input elements here for the customer's street address, let's comment them out for now so we can get this part of the form working. Now we're ready to try it out in the browser. And here is our first Reactive form. If the form does not display for you, use the developer tools and view the messages in the console. On this form, each of the input elements display correctly, and our default for the Send catalog checkbox is set to true. The address input elements don't display here because we commented them out. Looking at the values below the form, the value of each state here is false. If we give focus to the First Name field, and then leave the field, we see the appropriate validation error message, and we see that Touched now is true. If we type in a character we see the minimum length error message, and Dirty is now true, and if we put in valid values for each field, Valid is true. The Value property displays the key and value pairs for each FormControl registered with the FormGroup. Notice that the keys are the names we defined for each FormControl instance, and the values are our entered inputs, so the form model works the same, it's just that now we're creating it ourselves. But, what if we want to change the value of an input element from our component class? Say we want to set defaults after the form model is initialized. We aren't using two-way binding anymore, so changing the data model won't change the form values. How do we update the input element values on our form from our component class code?

Using setValue and patchValue

To update input elements on the form from our component class, we use setValue or patchValue. Use setValue to set the value of every FormControl in the form model. In this example, we have three FormControls and we set the value of each one. If we only want to set a subset of the values, we use patchValue instead, here we only set two of the values. Let's give this a try. To try this out, we'll add a button to our demo form template to provide some test data on the form. We'll use event binding to bind to a populateTestData method. Next, we need to write that method in the component class. I'll paste the code and we can talk through it. In this method, we use setValue to update each of the values in the form model. Let's check it out in the browser. Looking at the form, we see our new Test Data button. Click it, and the form populates with the defined values, but what if we only wanted to populate the name fields? If we go back to the method and remove the email address, for example, then look back at the form in the browser, if we open the developer tools, then click Test Data, we see an error message in the console, Must supply a value for form control with name: email. That's because the setValue requires that we set the value of every FormControl in the form model. What do we do? If you said patchValue, you are correct. Let's change setValue here to patchValue, recheck the form in the browser, click Test Data, and it works. Use setValue when setting all of the FormControls on the form, use patchValue to assign values for a subset of the FormControls. We'll see a more real-world example of these features later in this course. Looking back at the code that created the form model, this code is a bit long, and will be even longer if we add all of the address fields. Wouldn't it be nice if there was an easier way to write this code block? And there is, let's check out the FormBuilder next.

Simplifying with FormBuilder

FormBuilder is a class we can use when building Reactive forms to create the form model from a configuration. We can think of it as a factory that creates FormGroups and FormControls for us. The FormBuilder shortens the boilerplate code required to create an instance of the root FormGroup and its associated FormControls and nested FormGroups. This can make the code that creates the form model easier to read and maintain. The FormBuilder is provided as a service, so we access the FormBuilder instance using dependency injection. Since the FormBuilder is provided as a service, we follow the same steps we do for every other Angular server we use. We import FormBuilder with code that looks like this. We inject the FormBuilder instance using the class constructor, like this. Lastly, we use that instance to create our FormGroup, notice that we no longer need to create new instances of FormGroup or FormControl here. We'll look at this syntax more in a moment, first let's try out FormBuilder. Here in the component class we import FormBuilder from angular/forms. Our class currently has no explicit constructor, so we need to add one, then we inject the FormBuilder instance using the constructor parameter. Now we can use that FormBuilder instance to create our FormGroup. Instead of creating a root FormGroup instance using the new keyword, we'll use the FormBuilder instance and call its group method. The group method allows us to define the set of controls and nested FormGroups that are associated with the root FormGroup. Instead of explicitly creating a new FormControl instance, we simply set the default value. We could set the default value to anything, we'll set the defaults to an empty string for all but the sendCatalog FormControl. The group method returns an initialized root FormGroup instance with all of its associated FormControls and nested FormGroups. Now we can delete our original code, and remove FormControl from the import statement, because we no longer use it as a data type. Does this look easier to read without all of the cruft? Let's bring the form up in the browser and see that it still works. Let's take a closer look at the FormBuilder's FormControl syntax. The FormBuilder group method takes in a control configuration object that defines the FormControls associated with the FormGroup. In this example, we define two FormControls, firstName and sendCatalog. Each control configuration object is comprised of a key and value pair, the key is the FormControl name, such as firstName here. The value can be an expression that defines the default value for the FormControl. For example, the last entry has a key of sendCatalog and a default value of true. Alternatively, the value can be an object with two properties, value and disabled. The value property is the default value, as before, and the disabled property is a Boolean, defining whether the input element should be disabled. We'll see that in the upcoming demo. Yet another option allows specifying an array, the first element of the array is the default value expression or the object with the value and disabled state. The next two elements of the array, not shown here, define the validation rules. We'll look at validation in the next module. Now let's try out an alternate syntax. To try out an alternate syntax, let's change the lastName value to be an object with a default value and a disabled state. Let's check that out in the browser. We see that the last name default appears, and the input element is disabled, it works. Notice also that the lastName no longer appears in the Value property for the root FormGroup. This could be a useful feature in a situation that needs this functionality, but we don't need it here, so let's change it back to an empty string default. Looking back at our template, notice that our validation is all still here. We could leave it here, but if we want all of the benefits of Reactive forms, we'll want to move it into our component code as well. We'll do that in the next module. For now, let's finish up this module with some checklists we can use as we build our own Reactive forms.

Checklists & Summary

Checklists are a great way to recheck our understanding and our work. When building forms using the Reactive approach, the component class is in charge. In that class we create a property for the root FormGroup. We use this property to bind the form element in the template, then we create the FormGroup instance and pass in each FormControl instance, like this, but we can simplify this code using the FormBuilder. To use the FormBuilder, we import it using an import statement. We inject the FormBuilder instance into the class constructor, and we use that instance like this. The group method returns an initialized root FormGroup instance with all of its associated form controls. Before we can use the Reactive forms directives in our template, we need to pull them into our Angular module. We start by importing the ReactiveFormsModule using the import statement, we then add the ReactiveFormsModule to the imports array property of the ngModule decorator, like this. This makes the Reactive forms directives available to all templates associated with components defined in the declarations array. Note that our demo application has only one feature component, so it is defined in AppModule. In a real application, your form may be declared in a feature module. In that case, the ReactiveFormsModule should be added to the imports array of that feature module. We'll see this when we look at the APM sample application later in this course. We then bind the components template to the form model. In the form element we use the FormGroup directive and property binding to bind to the root FormGroup property we defined in the component class, in this example, that property was called customerForm. In each input element we used the FormControlName directive to bind to the name of the associated FormControl. The name we specify here is the name we set when creating the FormControl, and remember that these strings are case sensitive. After performing each of these steps, we have a Reactive form managed by the form model we define in the component class. In this module, we converted our template-driven form into a basic Reactive form. It began in the component class, where we explicitly created instances of the form building blocks, FormGroup and FormControl. Next we modified the application's Angular module to add the Reactive forms module to the imports array, and pull in the Reactive forms directives. Then we updated the template elements to bind to the FormGroup and FormControls we defined in the component class. We tried out the setValue and patchValue to update the input element values from the component code. Lastly, we saw how to use the FormBuilder to simplify the boilerplate code and create the root FormGroup and its associated FormControls with less cruft. But there's a bit more work to do, let's look at validation next.

Validation

Introduction

If only our users never made a mistake, never missed a required field, and always knew the constraints for each input element, we would not need validation, but I don't think we can make that assumption. Welcome back to Angular 2: Reactive Forms, from Pluralsight. My name is Deborah Kurata, and in this module we look at form validation, the Reactive way. The template-driven technique for validating form data is to specify appropriate validation attributes in the HTML. These validation rules determine if the user's entry is right or wrong, but what if it depends? What if we want to adjust the validation logic based on the user or on the state of the application? For example, we could perform different validation for administrators giving them more flexibility than normal users. Or we could validate differently based on the user's selection. If the user selects notification by text, phone is required, if by email, the email address is required. With Reactive forms we have much more control and can handle validation rules that specify right, wrong, or it depends. In this module, we examine how to set built-in validation rules in the component class, such as required and max length. We look at how to adjust those rules at runtime, based on desired criteria. We build a custom validator for the ultimate in validation flexibility. We expand our custom validator by passing in parameters, that way we can make our custom validator more generalized and reusable, but sometimes it's not enough to validate a single input element. We'll cover cross-field validation, and see how to validate a set of input elements as a group. Let's get started.

Setting Built-in Validation Rules

We've seen how to use the FormBuilder to create the root FormGroup, by specifying a FormControl with a default value for each of our input elements. Let's examine how to specify the validation rules here as well. Recall from the last module that we have three choices of syntax when defining a FormControl. We define a key value pair, where the key is the FormControl name and the value is the default input element value, such as an empty string or true in this example, or we can provide a key value pair where the value is an object with a value and disabled state. Or we define the FormControl's key value pair, where the value is an array. The first element of the array is the default input element value, the array syntax is the one we use to set validation rules for the FormControl. We set the validation rules in the second element of the array. For built-in validators we use the Validators class, and specify the name of the desired validation rule. In this example, we set the required validator. To specify multiple validation rules for a FormControl, use an array. In this example, we set the required validator and the minLength validator, passing in a 3 to specify a minimum length of 3 characters. So the first element of the array is the default value, and the second element to the array is an array of validation rules. The third element to the array, which is not shown here, is for any asynchronous validators. An asynchronous validator, as its name suggests, is for asynchronous validation operations. The most common use of asynchronous validation is calling a server-side validation method. To minimize the asynchronous calls, asynchronous validators are not executed until all synchronous validators pass validation. Notice that we can mix and match these styles. The firstName control uses an array because it has a validator. The sendCatalog FormControl specifies a simple default value because it needs no validator, so we can use the appropriate FormControl syntax for the requirements of each FormControl. Now let's set up some built-in validators. Looking at the HTML we can see that the First Name input element has two validation attributes, required and a minlength of 3. Let's delete these validation rules from the HTML. Now let's add them to the component class. Angular forms provides a validators class that has the basic validators built in. We import Validators from angular/forms to access those basic validators. We want to add validators to our firstName FormControl here, so we change the single value to an array. The first element of the array is our default value, the second element is for our validators. We can specify a single validator or an array of validators. In this example, we need both required and minlength, so we'll define an array of validators. We set Validators.required to mark the input element as required, and Validators.minLength, passing in a 3, to require a minimum length of 3 characters. Let's check it out in the browser. Set focus into the First Name, click out, and we see our required validation message. Now let's repeat this process for each of our other input elements. In the HTML, the Last Name has required and maxlength, let's delete these here and add them to our FormControl here. We change this single value to an array, then add the validators, Validators.required, Validators.maxLength 50. In the HTML the email has required and pattern, let's copy our pattern before we delete it, and add them to to our FormControl here, passing in the desired pattern. Our sendCatalog binds to a checkbox, so no validation is required. Let's check out the browser and see if all of our validation still works. First Name, yes, Last Name, yep, Email, you betcha. Our validation is now in our class. That was pretty easy, but how do we change that validation based on some criteria, such as a user selection?

Adjusting Validation Rules at Runtime

One of the benefits of using the Reactive forms approach is the ability to easily adjust validation rules at runtime. For example, we want administrative or internal users to have fewer required fields, we want different validation when creating data versus an update, or we need the validation to change based on another selection on the form. In this example, if the user selects to receive notification by text, then the phone field is required, otherwise the phone is optional. We change the validation for any FormControl at runtime by calling the setValidators method on that FormControl instance, and pass in the new validator. We can pass in a single validator or an array of validators. Here we change the validation to required and a maxLength of 30. We can remove all validators from a control calling clearValidators, this comes in handy if we want to add validation rules under some circumstances, and remove those rules under other conditions. However, updating the validators doesn't cause the validation status of the control to be reevaluated, so when we change the validators, if we want the control validation to be reevaluated based on the new validation rules, we need to call updateValueAndValidity on that FormControl as well. Let's jump back to the demo and give this a try. Since we last saw the demo application, I've added several input elements in the HTML. The Marketing Department wanted us to add a phone number, so I did that here, and set the formControlName directive to phone. We'll add phone to our FormBuilder in a moment. And the Marketing Department wanted radio buttons to set up notifications. The user can select to get notified via email or text. Notice that their values are email and text here. I've set the formControlName directive for each of the radio buttons to the same formControlName called notification; that allows us to track the radio buttons as one value. Now I need to add the FormControls for these input elements in the component class. We add phone for the phone input element, and we add notification for the set of radio buttons. Let's set the default value for the notification to email, that means initially the phone number input element is optional, and we don't need to define validation rules here. Since the user must pick one of the radio buttons, we don't need validation for notification either, but what if the user selects notification by text? We need to change the phone number validation to required. How are we going to do that? How about trying out setValidators? The first question we need to ask ourselves is where should we put the code that sets the validators? Well, what do we want it to do exactly? When the user clicks the email radio button, the phone number becomes optional, when the user clicks the text radio button, the phone number becomes required. So let's add a method that will call when either radio button is clicked. We'll call it setNotification, it takes in a string defining which radio button was clicked, and it returns a void. In the HTML, we use event binding on the click event for each radio button to call this setNotification method, passing in the appropriate text. Going back to the component class, in this setNotification method we use setValidators to change the validation of the phone input element appropriately. I'll paste the code, and we can talk through it. We first need a reference to the phone FormControl, remember from the last module how we do that? One way is to use the root FormGroup's get method to find the phone's FormControl within the form model. If the notification is via text, then we add the required validator for the phone FormControl by calling the setValidators method. We can pass in a single validator or an array of validators. In this example we only need one, required, otherwise we clear the validators for the phone FormControl. There is one more line of code we need here, after setting or clearing the validators, we need to reevaluate the phone FormControls validation state, so we call updateValueAndValidity. Let's check it out in the browser. We'll fill out the required fields so everything is valid. Now we see the Save button as enabled, and Valid is true. If we click the Text radio button, we see the phone validation error message, and the Save button is disabled. If we check email, the phone is no longer required, the validation message goes away, and the Save button is enabled. We now have a validation rule that adjusts itself at runtime. We can use setValidators, clearValidators, and the all-important updateValueAndValidity anytime we need to change the validation on the fly. Next, let's look at defining custom validation rules.

Custom Validators

Angular only provides basic validators, such as requiredMaxLength and pattern. Though we can do a lot with pattern, there are times we need custom validation rules. We define a custom validation rule with a custom validator. In its simplest form, a validator is a function. The validator function always takes one parameter, the FormControl or FormGroup being validated. To allow passing in either a FormControl or a FormGroup, we type the parameter using the abstract class, AbstractControl. This part of the syntax defines the type of value returned from this function. It looks a bit gnarly, so let's break it down. The validator function returns an object defining the broken rule, or null if it is valid. The returned object is comprised of a key and value pair, where the key is a string and the value is a Boolean. In the custom validator function we perform whatever logic we desire. If our logic determines that the validation rule passes, we return a null, if the validation rule fails, we return an object. The key is a string and defines the name of the broken validation rule. The value is set to true to indicate that the current entry has an error. The broken validation rule is then added to the passed in FormControl or FormGroup error collection. Let's build a custom validator. Someone in Marketing had this great idea to add a rate your experience element to the form. At some future point this will have a fancy user interface, such as selecting stars, but for now they want a simple text box where the user can enter 1 through 5. I've already added the requested rating input element here, and set the formControlName directive to rating. Let's add the FormControl for the rating to the form model, we'll use an empty string for the default value. We could add a pattern validator here to check a range of values, but to try out custom validation let's create our own numeric range validator. We can add our validator function above our component class. If this validator will only be used by this component, it makes sense to add it here, but if the validator could be used by other parts of the application, consider instead putting it in its own file. It can then more easily be reused by any component that needs it with a simple import statement. We'll see how to make a validator reusable later in this course. Let's call our validator function ratingRange. I'll paste the code, and we can walk through it. As discussed on the slides, a validator function always takes one parameter, the FormControl or FormGroup being validated. To allow either a FormControl or FormGroup, we specify AbstractControl here, and we need to import it from angular/forms. Next we define the return type of this function. A validator function always returns a key and value pair defining the broken validation rule, or a null if it is valid. We define our custom validation logic in the body of the validator function. For this specific example, we check if the control has a value that is not defined, is not a number, is less than 1, or greater than 5. If so we return the key and value pair specifying the name of the validation rule, we'll call it range, and true to indicate that the validation rule was broken. The validation rule name is then added to the errors collection for the passed in FormControl. If the control is valid, we return null. To set our new validator, we simple add it to the FormControl just like the built-in validators. We change the rating FormControl from a single value to an array, and pass the name of the validator function, ratingRange in our example, as the second parameter. Notice that we set the validation rule name here as range. In the HTML, if we want to display an error message for this particular validator we use the validation rule name, I've already done that here. Now let's see how it works in the browser. Here's our new Rating field, let's put in a 7, and we see our validation message. Change it to 4, and all is well. Adding custom validation is as easy as writing a function, the only odd part is ensuring the appropriate return value. Null if the FormControl is valid, a key and value pair if it is invalid, where the key is the name of the validation rule, and the value is true to add it to the list of validation errors. But notice that we hardcoded in the range here, what if we wanted to make this more generalized to work with a provided range of numbers?

Custom Validation with Parameters

The validator function we wrote works well for any simple validation, but what if we need parameters? For example, we want to limit entry to a provided range of values, we can't just add more parameters here. To define a custom validator with parameters, we need a more complex function that returns a validator function. Wait, what? Let's talk through this code. Because a validator function can only take one parameter, the AbstractControl to validate, we can't simply pass more parameters to this function, instead we build a factory function that returns the validator function. Here we have our factory function, we can specify any number and type of parameters here. This factor function returns a validator function, so we define ValidatorFn as the return type, and return our validator function. This is the same validator function that we saw on the prior slide, but instead of declaring and naming this function, we simple return it using the arrow function syntax. Let's give this a try. We want to change our ratingRange validator to take in a minimum acceptable value and a maximum acceptable value, so this validator can be used for ranges other than one that is hardcoded in. Currently we hardcoded in a range between 1 and 5. As we saw in the slide, we can't simply pass more parameters to this validator function. Rather, we need to wrap this function in a factory function, like this. The function takes in the minimum acceptable value, and the maximum acceptable value, and returns a validator function. Oh, and we need to add ValidatorFn to the import statement, then we return our validator function by changing it to an arrow function, we add the return statement, we remove function and the function name, and we add an arrow here to define the returned validator function. Next, we modify the logic of the validator function to use the passed in parameters. We'll change the 1 here to min, and the 5 to max. Now we can change the FormControl validation to pass in the minimum and maximum values. Does it still work? Try a 7, error, 5, it's good, 0, another error, 2, it's good, it works. Modifying a validator function to accept parameters requires wrapping the validator function in a factory function. That factory function takes in any desired parameters, and returns the validator function. Then we modify the validator function to use those provided parameters, but what if we need to validate across multiple FormControls?

Cross-Field Validation: Nested FormGroup

Sometimes, simple FormControl validation is not enough, we need to compare across two or more form controls. A common example of this is to compare a start date and end date to ensure the start date is before the end date, or to confirm entry of a password or email address. The trick to cross-field validation is to define a nested FormGroup for the FormControls that are validated together. We define them as a FormGroup both in the component and in the HTML. In the component class, we define a nested group within the forms root FormGroup. In this example, we name this nested group availability. To create a nested group we use the same syntax as when we create the forms root FormGroup. We call the group method of the FormBuilder, any FormControl to be validated as part of the group is then defined within this nested FormGroup. In our example, we have two FormControls, but there could be any number of FormControls, or more nested FormGroups defined in this group. We set each FormControls default value and validation as we have throughout this module. In the HTML we define a container element, such as this div element, to enclose the input elements associated with the FormGroup, and then use the formGroupName directive to associate the container element with our nested FormGroup. The input elements within the container use the formControlName directive assigned to the name of the FormControl within the nested FormGroup. Once we have the grouping in place, we can perform the cross-field validation, but let's take it one step at a time, and add the nested FormGroup first. The Marketing Department has gotten too many returned emails, and believe it is because the user has mistyped their email address in the form, so they've requested that we add an email confirmation text box. This may not be the greatest idea, but it provides a simple example of cross-field validation. I've already added the confirm email input element, it looks similar to the email input element. Here the formControlName directive is set to confirmEmail. Now let's add the FormControl for this Confirm Email input element to the form model in our component class. We add confirmEmail, we don't need a default value, and we specify the required validator. We could also specify the pattern validator here, but if we are comparing it against the email FormControl, which already has the pattern validator, we don't really need it here. Recall from the slides that the first step to making the cross-field validation is to create a nested FormGroup for the form controls to validate as a group. Let's name that group emailGroup, and create the nested group by calling the group method of the FormBuilder. We can then copy our two email form controls into that nested form group and reformat. The resulting form model has a root FormGroup here and the nested FormGroup here. Now let's group the HTML as well. First we define an element that surrounds the input elements to validate as a group. We'll specify a div element and reformat. Note that the form-group here is just a Bootstrap style class, and does not affect our form model. We then use the formGroupName directive and set it to the name of our FormGroup, which is emailGroup. Now that the FormControls are within a nested FormGroup, we need to change each reference to the FormControl. We could use customerForm.controls.emailGroup.controls.email to drill down from the form to the FormGroup to the control, but here is where the FormGroup's get method can simplify our syntax. We make this change everywhere we are referring to this control; we make a similar change for the confirmEmail. Let's view the result in the browser. Here's our new Confirm Email input element, our required field validation works for the Email and for the Confirm Email. Notice I've misspelled the second email address, and we're not getting an error message on the cross-field validation. That's because we haven't written it yet. Notice that our Value property here at the bottom now shows our nested group. Great, let's move on to building the cross-field validator.

Cross-field Validation: Custom Validator

Now that we've defined our set of FormControls as a FormGroup, we could build a validator function similar to the one we built earlier in this module. If the validation does not require parameters, we can build a simple validator function, otherwise we can build a factory function that returns a validator function. In either case, we are validating the nested FormGroup, so that FormGroup is passed in to this method. To validate the contents of the multiple FormControls, we first access the FormControls from the passed in FormGroup using the get method. In this example, we get the FormControl named start, and the FormControl named end. We then compare their values as needed, and return null if the validation rules passes, or a validation error object if the validation fails. Then we add the validator to the FormGroup. Note that we can't simply add the validator function here, the FormGroup signature requires that we provide an object with a validator key and the function as the value. Let's see cross-field validation in action. We'll create the validator function here, I'll just paste it in, and we can talk through it. The function is called emailMatcher. We don't need any extra parameters, so we just use the simple validator function. The parameter here will be a passed in FormGroup. We call the get method of the FormGroup to find both the email and confirmEmail FormControls. We then use these references to check the value of the email FormControl against the value of the confirmEmail FormControl. If the values match, we return null. If the values don't match, we return a key and value pair, where the key is the name of the validation rule and the value is true to add this rule to the errors collection for the FormGroup. Let me say that again. This adds the broken validation rule name to the errors collection for the FormGroup, not the individual FormControls. And because we don't want the validation to return an error until the user has touched the fields, let's add one more condition to our validator function. If either the email FormControl or the confirmEmail FormControl has not yet been touched, return null, and skip the validation. Next, we add this validator to the nested FormGroup as the second argument. Recall from the slides that we can't simply add the validator function here, instead we pass an object with a validator property. To let the user know that there's a problem, let's add a style class to the group in the HTML. Here we set the style using the Bootstrap has-error class, if the emailGroup has any errors defined in its errors collection. Let's check it out in the browser. We type in an email address, and the Confirm Email does not yet turn red. As soon as we type anything into the confirmation element, both fields turn red because they don't match. When we type in a matching email address, the has-error style is removed, and the elements are no longer red. But just turning elements red is not very user friendly, let's add a validation message for the user. Let's put the validation message on the Confirm Email element. Our first thought might be to add something like this. The problem is, however, that the FormControl doesn't get a match entry in its errors collection, rather the match error appears in the errors collection for the FormGroup. We instead need to change this to check the emailGroup's errors collection. If we tried it at this point, it still wouldn't display the message because of this ngIf block here. This ngIf checks the confirmEmail FormControl and its errors collection. We need to add another or expression, and add another parenthesis here. Now these span elements are displayed if either the confirmEmail or the emailGroup errors collection has a value. This leads us to another problem. Because we are now displaying these spans when the nested FormGroup has an error, not necessarily when the Confirm Email has an error, we need to add the safe navigation operator here and here. This prevents the cannot read property required of null type of error. As you can see, the checks here for displaying the error messages are getting even more messy. We'll refactor this code, pushing much of this logic into the component class later in this course. For now, let's check this out in the browser. We'll put in an email address and start entering the confirmation email, we see the message that they don't match. As soon as it does match our error message disappears, it works, yeah. To implement cross-field validation, we create a nested FormGroup, and add the FormControls to be validated to that nested group. We then set the formGroupName directive on an HTML element that encapsulates the associated input elements. We wrote the validator function, and specified that validator when creating the nested FormGroup. Let's finish this module with some checklists we can use as we add validation to our applications.

Checklists and Summary

When setting any of the built-in validation rules for FormControl, start by adding an import statement for validators, then pass the validator or array of validators as the second element in the value for the FormControl. In this example, we pass a single validator for the firstName, and an array of validators for the lastName. To adjust the validation rules at runtime based on some criteria, first determine when to make the change. If it is based on user action, tie it to that user action. Next, we call the FormControl's setValidators method, and pass in the validator, or an array of validators, or we can clear all validators with clearValidators, like this. And always remember to call the FormControl's updateValueAndValidity. Calling setValidators or clearValidators does not trigger any update or value changed events, so the validation is not reevaluated. Call updateValueAndValidity to trigger the validation. Any time we need specialized rules for validating a FormControl, we build a custom validator. A custom validator is simply a function that takes in the control to validate and returns a null if the control is valid, or a validation error object, like this. The validation error object is a key and value pair, where the key is the name of the validation rule, and the value is true. This key is used as the name of the broken validation rule when it appears in the errors collection for the FormControl. We then use our custom validator just like any other validator, like so. Here the firstName FormControl is validated with our custom validator. It is important to note that we can also use any custom validators with the template-driven forms approach. We just need to expose our custom validator function as a directive, then the directive can be applied to the HTML elements, just like the built-in attributes such as required and max length. If we need to pass parameters to our custom validator function, we wrap it in a factory function, like this. We specify the desired parameters here, and return a validator function using the arrow function syntax. We then use the custom validator just like any other validator that has parameters, like this. When we need to validate across two or more FormControls, we group the controls to validate in a nested FormGroup. We start by defining a nested FormGroup, and adding the FormControls to validate to that group, as so. Even though we are showing two FormControls here, any number of FormControls or other nested FormGroups could belong to this nested FormControl. We then update the HTML. We define a container element around the controls to validate. We use the formGroupName directive and assign it to the nested formGroupName. Once we have the FormControls to validate within a nested FormGroup, we build the custom validator. We can build a validator function without parameters as shown here, or with parameters using a factory function, as shown previously. Either way, we then use the validator like this. When adding validators to a FormGroup, we provide it as an object with a key and value pair. The key is validator and the value is the validator function. In this module, we focused on validation. We began by working with the built-in validators, and saw how to define one or more validators for each FormControl. Next, we looked at how to adjust the validation rules at runtime based on desired criteria. We then examined how to perform custom validation by building a validator function. We created a function to validate a numeric value to ensure it fell within a hardcoded range of values. We expanded on our custom validator by adding parameters, this allows any FormControl that uses our custom validator to define the desired range of values. Lastly, we saw how to validate several fields as a group. Next up, let's see how to listen for changes on the form and react accordingly.

Reacting to Changes

Introduction

With Reactive forms we can adjust how a form works reactively, based on user entries and selections. Welcome back to Angular 2: Reactive Forms, from Pluralsight. My name is Deborah Kurata, and in this module we explore how to watch for user changes, and react to those changes dynamically controlling the form. What if we could watch every change that the user makes, every character, every keystroke? Yeah that might sound a bit creepy, but in Reactive forms it's a good thing, really. By watching the user's changes we can modify the display, the validation, or the messages, providing a much more dynamic and personal experience. In this module, we learn how to watch for user changes, we look at ways we can react to those changes, and we examine reactive transformations to improve how we watch those changes. Let's get started.